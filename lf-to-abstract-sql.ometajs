var SBVRCompilerLibs = require('./sbvr-compiler-libs').SBVRCompilerLibs,
	_ = require('lodash'),
	updateModifiedAt = {
		type: 'trigger',
		body: 'NEW."modified at" = NOW();\nRETURN NEW;',
		language: 'plpgsql'
	},
	LINK_RESOLVE_QUEUED = true,
	LINK_RESOLVE_DONE = false;

export ometa LF2AbstractSQL <: SBVRCompilerLibs {
	Number =
		[	'Number'
			number:num
			?{!isNaN(num)}
		]
		-> num,

	Real =
		[	'Real'
			number:num
			?{!isNaN(num)}
		]
		-> ['Real', num],

	Integer =
		[	'Integer'
			number:num
			?{!isNaN(num)}
		]
		-> ['Integer', num],

	Text =
		[	'Text'
			anything:text
		]
		-> ['Text', text],

	Value =
			Real
		|	Integer
		|	Text,

	/** Terms **/
	Identifier =
		[	(	'Term'
			|	'Name'
			):type
			:name
			:vocab
			(	// Var number
				Number:num
			|	// Or embedded data, which we ignore the embedded data as it is retreived from the binding instead
				Value
			)?
		]
		-> {type: type, name: name, num: num, vocab: vocab},

	IdentifierName =
		:identifierName
		GetResourceName(identifierName):resourceName
		(	?(!this.tables.hasOwnProperty(resourceName))
		|	{console.error('We already have an identifier with a name of: ' + identifierName)} ?(false)
		)
		CreateTable(resourceName, identifierName)
		-> identifierName,
	Attributes :termOrFactType =
			end
		|	[	'Attributes'
				{{}}:attributes
				(	[	:attributeName
						(anything)*:attributeVals
					]
					{attributes[attributeName] = attributes[attributeName] || []}
					{attributes[attributeName].push(attributeVals)}
				)*
			]
			{[
				'DatabaseTableName',
				'DatabaseIDField',
				'DatabasePrimitive',
				'TermForm',
				'ConceptType',
				'SynonymousForm',
				'Synonym',
				'ReferenceScheme',
				'ForeignKey',
				'ReferenceType',
				'Attribute',
				'Unique'
			]}:attrOrder
			{
				attrOrder.forEach(function(attributeName) {
					if(attributes.hasOwnProperty(attributeName)) {
						attributes[attributeName].forEach(function(attributeVal) {
							$elf._applyWithArgs.apply($elf, ['Attr' + attributeName, termOrFactType].concat(attributeVal));
						});
					}
				});
				_(attributes).omit(attrOrder).forEach(function(attributeVals, attributeName) {
					attributeVals.forEach(function(attributeVal) {
						$elf._applyWithArgs.apply($elf, ['ApplyFirstExisting', ['Attr' + attributeName, 'DefaultAttr'], [termOrFactType].concat(attributeVal)]);
					});
				});
			}
	,
	DefaultAttr :termOrFactType =
		anything,
	AttrConceptType :termOrFactType =
		[	'Term'
			:conceptType
			:vocab
		]:conceptTerm
		{	if (this.termForms[termOrFactType]) {
				termOrFactType = this.termForms[termOrFactType];
			}
		}
		{this.vocabularies[termOrFactType[2]]['ConceptTypes'][termOrFactType] = conceptTerm}

		IsPrimitive(conceptTerm):primitive
		GetTable(conceptType):conceptTable
		GetTable(termOrFactType[1]):identifierTable
		(	?(primitive !== false && conceptType === primitive)
			{primitive}:dataType
			// If the concept type is primitive then we use that as the "value" field and delete the current.
			(	?(identifierTable.hasOwnProperty('referenceScheme'))
				GetTableFieldID(identifierTable, identifierTable.referenceScheme):fieldID
				?(fieldID !== false)
				{identifierTable.fields.splice(fieldID, 1)}
			)?
			{identifierTable.referenceScheme = conceptType}
		|	{'ConceptType'}:dataType
			GetReference(conceptTable):references

			// Only add the `is of` reverse reference when the concept type is not a primitive
			GetReference(identifierTable, conceptType):reverseReferences
			AddRelationship(conceptTable, [['Verb', 'is of'], termOrFactType], references.fieldName, reverseReferences)
		)
		AddTableField(identifierTable, conceptType, dataType, true, null, references)
		AddRelationship(identifierTable, [['Verb', 'has'], conceptTerm], conceptType, references)
	,
	AttrDatabaseIDField :termOrFactType =
		:idField
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?(typeof table === 'string')
		|	(	AddTableField(table, idField, 'Serial', true, 'PRIMARY KEY'):fieldID
				(	?(fieldID !== false)
					// If the field already exists then update it instead.
					{table.fields[fieldID].index = 'PRIMARY KEY'}
				)?
			)
			{table.idField = idField}
		),
	AttrReferenceScheme :termOrFactType =
		:referenceScheme
		(	?Array.isArray(referenceScheme)
			-> referenceScheme[1]
		|	-> referenceScheme
		):referenceScheme
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?(typeof table === 'string')
		|	// Find existing name field and update it if it exists.
			(	?(table.hasOwnProperty('referenceScheme'))
				GetTableFieldID(table, table.referenceScheme):fieldID
				?(fieldID !== false)
				{table.fields[fieldID].fieldName = referenceScheme}
			)?
			{table.referenceScheme = referenceScheme}
		),
	AttrDatabaseTableName :termOrFactType =
		:tableName
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?(typeof table === 'string')
		|	{table.name = tableName}
		)
		(	?(Array.isArray(termOrFactType[0]) && termOrFactType.length > 2)
			GetResourceName(termOrFactType):linkResourceName
			GetTable(termOrFactType[0][1]):baseTable
			// When we add the table name to the link table we have to add the relationship to it from the base table
			FactTypeFieldName([ ['Term', linkResourceName], ['Verb', 'has'], termOrFactType[0] ]):fieldName
			GetReference(table, fieldName):references
			AddRelationship(baseTable, termOrFactType.slice(1), baseTable.idField, references, true)
			AddRelationship(baseTable, termOrFactType, baseTable.idField, references, true)
		)?,
	AttrDatabasePrimitive :termOrFactType =
		:attrVal
		GetTableID(termOrFactType):tableID
		{this.GetTable(tableID).primitive = attrVal},
	AttrDatabaseAttribute :factType =
		:attrVal
		(	?attrVal
			{this.attributes[factType] = attrVal}
			GetResourceName(factType):linkResourceName
			{delete this.relationships[linkResourceName]}
			{this.tables[linkResourceName] = 'Attribute'}
			GetTable(factType[0][1]):baseTable
			FactTypeFieldName(factType):fieldName
			GetTable(factType[2][1]):attributeTable
			GetTableFieldID(baseTable, fieldName):fieldID
			{baseTable.fields[fieldID].dataType = attributeTable.primitive}
			// Overwrite the foreign key relationships with attribute ones
			AddRelationship(baseTable, factType, fieldName)
			AddRelationship(baseTable, factType.slice(1), fieldName)
		)?,
	AttrForeignKey :factType =
		:required
		GetTable(factType[0][1]):baseTable
		{factType[2][1]}:foreignTerm
		FactTypeFieldName(factType):fkName
		GetTable(foreignTerm):fkTable
		(	?(baseTable.idField == fkName)
			// If the foreign key matches the id field then delete the current field before adding the new.
			GetTableFieldID(baseTable, fkName):fieldID
			?(fieldID !== false)
			// But we keep any indexes intact
			{baseTable.fields[fieldID].index}:index
			{baseTable.fields.splice(fieldID, 1)}
		)?
		GetReference(fkTable):references
		AddTableField(baseTable, fkName, 'ForeignKey', required, index, references):fieldID
		AddRelationship(baseTable, factType.slice(1), fkName, references)
		GetResourceName(factType):factTypeResourceName
		{
			_.forEach($elf.synonymousForms[factTypeResourceName], function(synForm) {
				var actualFactType = $elf.MappedFactType(synForm);
				if (actualFactType[0][3] === 0) {
					$elf.AddRelationship(baseTable, synForm.slice(1), fkName, references);
				} else {
					var synResourceName = $elf.GetResourceName(synForm[0][1]);
					var reverseReferences = $elf.GetReference(baseTable, fkName);
					$elf.AddRelationship(synResourceName, synForm.slice(1), references.fieldName, reverseReferences);
				}
			})
		}
		(	?fieldID
			// Field already exists, so we manually set the required attr
			{baseTable.fields[fieldID].required = required}
		)?
		GetResourceName(factType):linkResourceName
		{delete this.relationships[linkResourceName]}
		{this.tables[linkResourceName] = 'ForeignKey'},
	AttrReferenceType :factType =
		:referenceType
		GetTable(factType[0][1]):baseTable
		FactTypeFieldName(factType):fkName
		GetTableFieldID(baseTable, fkName):fieldID
		?(fieldID !== false)
		{baseTable.fields[fieldID].references.type = referenceType},
	AttrUnique :factType =
		:required
		GetTable(factType):baseTable
		(	?(baseTable === 'Attribute' || baseTable === 'ForeignKey')
			GetTable(factType[0][1]):baseTable
		)?
		FactTypeFieldName(factType):uniqueField
		GetTableFieldID(baseTable, uniqueField):fieldID
		?(fieldID !== false)
		{baseTable.fields[fieldID].index = 'UNIQUE'},
	AttrSynonym :term =
		:synonym
		{this.synonyms[synonym[1]] = term[1]}
	,
	AttrSynonymousForm :factType =
		:synForm
		AddFactType(synForm, factType)
		(	?(this.IsPrimitive(factType[0]) || this.IsPrimitive(synForm[0]))
			// If we're on a primitive fact type we do nothing
		|	GetResourceName(factType):resourceName
			{	if(this.synonymousForms[resourceName] == null) {
					this.synonymousForms[resourceName] = [];
				}
				this.synonymousForms[resourceName].push(synForm)
			}
			FactTypeFieldName(factType):fieldName
			(	?(factType.length == 2)
				GetResourceName(factType[0][1]):resourceName
				AddRelationship(resourceName, synForm.slice(1), fieldName)
			|	GetTable(synForm[2][1]):fkTable
				(	?(!fkTable.primitive)
					GetReference(fkTable)
				)?:references
				AddRelationship(resourceName, synForm.slice(1), synForm[2][1], references)
				(	?references
					GetTable(factType):linkTable
					GetTable(synForm[0][1]):fromTable
					// If we're on the first identifier we add a link from it to the link table
					GetReference(linkTable, fieldName):linkRef
					AddRelationship(fromTable, synForm.slice(1), references.fieldName, linkRef)
				)?
			)
		)
	,
	AttrTermForm :factType =
		:termForm
		GetResourceName(factType):linkResourceName
		GetTable(factType):linkTable
		{	var linkVerb;
			this.termForms[factType] = termForm;
			this.synonyms[termForm[1]] = linkResourceName;
			for(var i = 0; i < factType.length; i++) {
				if(factType[i][0] === 'Term') {
					var hasFactType = [termForm, ['Verb', 'has', false], factType[i]];
					var extraFactType = [ termForm, linkVerb || ['Verb', 'has'], factType[i] ];
					this.AddFactType(hasFactType, extraFactType);
					if (linkVerb && linkVerb[1] !== 'has') {
						this.AddFactType(extraFactType, extraFactType);
					}
					var termTable = this.GetTable(factType[i][1]);
					if (termTable.primitive) {
						this.tables[this.GetResourceName(extraFactType)] = 'Attribute';
					} else {
						this.tables[this.GetResourceName(extraFactType)] = 'ForeignKey';
						var fieldName = this.FactTypeFieldName(extraFactType);
						var references = this.GetReference(linkTable, fieldName);
						this.AddRelationship(termTable, [['Verb', 'has'], termForm], termTable.idField, references);
					}
				} else if (factType[i][0] === 'Verb') {
					linkVerb = factType[i]
				}
			}
		},
	AttrNecessity :tableID =
		Rule,
	AttrDefinition :factType =
			[	'Enum'
				Value+:values
			]

			GetTable(factType):baseTable
			(	?(baseTable === 'Attribute' || baseTable === 'ForeignKey')
				GetTable(factType[0][1]):baseTable
			)?
			// Check we were able to find the base table, if not it's probably
			// a definition on a term and not a fact type
			?baseTable
			FactTypeFieldName(factType):uniqueField
			GetTableFieldID(baseTable, uniqueField):fieldID
			?(fieldID !== false)
			{baseTable.fields[fieldID].checks = baseTable.fields[fieldID].checks || []}:checks
			{checks.push(
				[	'In',
					[	'Field',
						baseTable.fields[fieldID].fieldName
					]
				].concat(values)
			)}
		|	anything
	,

	/** Fact Types **/
	FactType =
		&((:factTypePart &(:attributes) -> factTypePart)+:factType)
		AddFactType(factType, factType)
		(	?(this.IsPrimitive(factType[0]))
			// Eat input
			(:factTypePart &(:attributes))+
		|	GetResourceName(factType):resourceName
			(	?(factType.length == 2)
				// Eat input
				(:factTypePart &(:attributes))+
				GetTable(factType[0][1]):identifierTable
				FactTypeFieldName(factType):fieldName
				AddTableField(identifierTable, fieldName, 'Boolean', true)
				{delete this.relationships[resourceName]}
				{this.tables[resourceName] = 'BooleanAttribute'}
				AddRelationship(identifierTable, factType.slice(1), fieldName)
			|	CreateTable(resourceName, _(factType).map(1).join(' ')):linkTable
				{[]}:uniqueFields
				(	Identifier:identifier
					{[ ['Term', resourceName], ['Verb', 'has'], ['Term', identifier.name] ]}:linkHasFactType
					{[ ['Term', resourceName], linkVerb, ['Term', identifier.name] ]}:linkVerbFactType
					(	?linkVerb
						// If we've seen a verb then we can use it in the name, indicating the direction (particularly important for self-referential many-many)
						FactTypeFieldName(linkVerbFactType)
					|	FactTypeFieldName(linkHasFactType)
					):fieldName
					{uniqueFields.push(fieldName)}
					GetTable(identifier.name):fkTable
					(	?fkTable.primitive
						AddTableField(linkTable, fieldName, fkTable.primitive, true)
						-> null
					|	GetReference(fkTable):references
						AddTableField(linkTable, fieldName, 'ForeignKey', true, null, references):fieldID
						-> references
					):references
					AddRelationship(resourceName, linkHasFactType.slice(2), fieldName, references)
					(	?linkVerb
						AddRelationship(resourceName, linkVerbFactType.slice(1), fieldName, references)
					)?
				|	['Verb' :verb :negated]
					{['Verb', verb]}:linkVerb
				)+
				{linkTable.indexes.push({type: 'UNIQUE', fields: uniqueFields})}
			)
		)
		-> factType,

	Cardinality =
		[
			(	'MinimumCardinality'
			|	'MaximumCardinality'
			|	'Cardinality'
			)
			Number:cardinality
		]
		-> cardinality,

	Variable =
		[	'Variable'
			Number:num
			Identifier:identifier
			(	// Don't add this var if it's an attribute binding.
				{this.bindAttributes[num]}:bind
				?bind
				{_.clone(bind.binding)}:selectBody
				-> ['SelectQuery', ['Select', [selectBody]]]
			|	{'.' + num}:varNum
				{['SelectQuery', ['Select', []]]}:query
				CreateConceptTypesResolver(query, identifier, varNum):checkConceptTypeResolver
				-> query
			):query
			(	{checkConceptTypeResolver && checkConceptTypeResolver()}
				RulePart:whereBody
				AddWhereClause(query, whereBody)
			)?
		]
		(	{checkConceptTypeResolver && checkConceptTypeResolver()}
			RulePart:whereBody
			AddWhereClause(query, whereBody)
		)?
		(	?(selectBody && !query.some(function (p) { return p[0] === 'From'; }))
			(	{query.find(function(part) { return part[0] === 'Where'; })}:whereBody
				?whereBody
				{selectBody.whereBody = whereBody[1]}
			)?
			-> selectBody
		|	-> query
		),

	// Return role bindings as they would be found in the actual fact type.
	RoleBindings :actualFactType =
		{[]}:binds
		{	for(var i = 0; i < actualFactType.length; i += 2) {
				var j = actualFactType.findIndex(function (p) { return p[3] === i; });
				// Map the bind into the position matching that of the fact type.
				binds[j/2] = this.RoleBinding(actualFactType[j][1]);
			}
		}
		end
		-> binds
	,

	RoleBinding :baseTermName =
		[	'RoleBinding'
			Identifier:identifier
			(	number:number
			|	Value:data
			|	NativeNameBinding(baseTermName):nativeNameBinding
			)
		]
		(	?data
			-> data
		|	?nativeNameBinding
			-> nativeNameBinding
		|	{this.bindAttributes[number]}:baseBind
			?baseBind
			-> baseBind.binding
		|	{this.conceptTypeResolvers[identifier.name + '.' + number]}:conceptTypeResolver
			-> ['ReferencedField', baseTermName + '.' + number, identifier.name]
		):binding
		-> {
			identifier: identifier,
			number: number,
			data: data,
			binding: binding,
			used: function() {
				if (conceptTypeResolver) {
					conceptTypeResolver(baseTermName)
				}
			}
		},

	NativeNameBinding :baseTermName =
		Identifier:name
		?(name.type === 'Name')
		?(this.IsPrimitive(this.ReconstructIdentifier(name)))

		?(this.sbvrTypes[baseTermName] &&
			this.sbvrTypes[baseTermName].nativeNames &&
			this.sbvrTypes[baseTermName].nativeNames[name.name])
		-> this.sbvrTypes[baseTermName].nativeNames[name.name],

	NativeProperty :actualFactType =
		?(this.IsPrimitive(actualFactType[0]))
		?(this.IsPrimitive(actualFactType[2]))
		RoleBindings(actualFactType):binds
		{actualFactType[1][2]}:negated
		(	?negated
			-> 'NotEquals'
		|	-> 'Equals'
		):operator
		?(binds.length == 2)
		{actualFactType[0][1]}:primitive
		{actualFactType[1][1]}:verb
		{actualFactType[2][1]}:property
		?(this.sbvrTypes[primitive] &&
			this.sbvrTypes[primitive].nativeProperties &&
			this.sbvrTypes[primitive].nativeProperties[verb] &&
			this.sbvrTypes[primitive].nativeProperties[verb][property])
		-> [operator, ['Boolean', true], ['Boolean', true]],

	NativeFactType :actualFactType =
		?(actualFactType.length == 3)
		?(this.IsPrimitive(actualFactType[0]))
		?(this.IsPrimitive(actualFactType[2]))
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{actualFactType[0][1]}:primitive
			{actualFactType[1][1]}:verb
			{actualFactType[2][1]}:secondPrimitive
			?(this.sbvrTypes[primitive] &&
				this.sbvrTypes[primitive].nativeFactTypes &&
				this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive] &&
				this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb])
			{this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb](binds[0].binding, binds[1].binding)}:comparison
			{actualFactType[1][2]}:negated
			(	?negated
				-> ['Not', comparison]
			|	-> comparison
			)
		|	___NativeFactTypeMatchingFailed___.die
		),


	LinkTableAlias =
		[	(	:binding
				-> binding.number
			)+:bindNumbers
		]
		[	(	[	(	'Verb'
						:verb
						anything
						-> verb
					|	:identifierType
						:identifierName
						:vocab
						anything?:mapping
						-> (identifierName + '.' + bindNumbers.shift())
					):partAlias
				]
				-> partAlias
			)*:factType
		]
		-> factType.join('-'),
	LinkTable :actualFactType =
		RoleBindings(actualFactType):binds
		LinkTableAlias(binds, actualFactType):tableAlias
		GetTable(actualFactType):linkTable
		{['SelectQuery', ['Select', []], ['From', ['Alias', ['Table', linkTable.name], tableAlias]]]}:query
		{	binds.forEach(function(bind, i) {
				var baseIdentifierName = actualFactType[i*2][1],
					targetTable = $elf.GetTable(baseIdentifierName);
				if(!targetTable.primitive) {
					var relationships = $elf.relationships[linkTable.resourceName];
					$elf.ResolveSynonym(baseIdentifierName).split('-').forEach(function(partName) {
						relationships = relationships[partName];
					});
					var relationshipMapping = relationships.$;
					$elf.CreateLinkTableResolver(query, tableAlias, bind, relationshipMapping);
				}
			})
		}
		{actualFactType[1][2]}:negated
		(	?negated
			-> 'NotExists'
		|	-> 'Exists'
		):operator
		-> [operator, query],

	ForeignKey :actualFactType =
		?(this.GetTable(actualFactType) == 'ForeignKey')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{binds[0]}:bindFrom
			{binds[1]}:bindTo
			FactTypeFieldName(actualFactType):fieldName
			GetTable(actualFactType[2][1]):tableTo
		|	___ForeignKeyMatchingFailed___.die
		)
		{
			bindFrom.used();
			bindTo.used();
		}
		{actualFactType[1][2]}:negated
		(	?negated
			-> 'NotEquals'
		|	-> 'Equals'
		):operator
		-> [operator, ['ReferencedField', bindFrom.binding[1], fieldName], ['ReferencedField', bindTo.binding[1], tableTo.idField]],

	BooleanAttribute :actualFactType =
		?(this.GetTable(actualFactType) == 'BooleanAttribute')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 1)
			FactTypeFieldName(actualFactType):attributeName
			{actualFactType[1][2]}:negated
		|	{console.error(this.input)}
			___BooleanAttributeMatchingFailed___.die
		)
		{binds[0].used()}
		-> ['Equals', ['ReferencedField', binds[0].binding[1], attributeName], ['Boolean', !negated]],

	Attribute :actualFactType =
		?(this.GetTable(actualFactType) == 'Attribute')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{binds[0]}:bindReal
			{binds[1]}:bindAttr
			|	___AttributeMatchingFailed___.die
		)
		{actualFactType[1][2]}:negated
		(	?negated
			-> 'NotEquals'
		|	-> 'Equals'
		):operator
		(	{this.bindAttributes[bindAttr.number]}:bind
			{
				bindReal.used();
				bindAttr.binding = ['ReferencedField', bindReal.binding[1], bind.binding[2]]
			}
			?(!_.isEqual(bindAttr.binding, bind.binding))
			// If we're not the first bind we make sure we match it.
			-> [operator, bindAttr.binding, bind.binding]
		|	// Otherwise return true = true, just so things work.
			-> [operator, ['Boolean', true], ['Boolean', true]]
		),

	AtomicFormulation =
		[	'AtomicFormulation'
			[	'FactType'
				anything+:factType
			]
			MappedFactType(factType):actualFactType
			(	NativeProperty(actualFactType)
			|	NativeFactType(actualFactType)
			|	ForeignKey(actualFactType)
			|	BooleanAttribute(actualFactType)
			|	Attribute(actualFactType)
			|	LinkTable(actualFactType)
			):whereClause
		]
		-> whereClause,
	AtLeast =
		[	'AtLeastNQuantification'
			Cardinality:minCard
			Variable:variable
		]
		(	?(minCard == 0)
			// At least 0? Well that's always true..
			-> ['Boolean', true]
		|	(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
				// Variable is an empty query so we do a count.
				{variable[1][1].push(['Count', '*'])}
				-> ['GreaterThanOrEqual', variable, ['Number', minCard]]
			|	// Otherwise we're an attribute
				(	?(minCard > 1)
					// And to have more than one of an attribute is impossible.
					-> ['Boolean', false]
				|	-> ['Exists', variable]
				)
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	UniversalQuantification =
		[	'UniversalQuantification'
			anything:v
			anything+:xs
			// For a universal quantification instead of checking that everything matches to checking there are no counter examples
			// We use an `COUNT(*) = 0` rather than `NOT EXISTS` because it reliably performs better
			Exactly(['ExactQuantification', ['Cardinality', ['Number', 0]], v, ['LogicalNegation'].concat(xs)]):x
		]
		-> x,
	Exactly =
		[	'ExactQuantification'
			Cardinality:card
			Variable:variable
		]
		(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
			// Variable is an empty query so we do a count.
			{variable[1][1].push(['Count', '*'])}
			-> ['Equals', variable, ['Number', card]]
		|	// Otherwise we're an attribute
			{['Exists', variable]}:exists
			(	?(card == 0)
				// Exactly 0 attributes is a non-existent (null) attribute
				-> ['Not', exists]
			|	?(card == 1)
				// Exactly 1 is existent.
				-> exists
			|	// And anything else is impossible.
				-> ['Boolean', false]
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Range =
		[	'NumericalRangeQuantification'
			Cardinality:minCard
			Cardinality:maxCard
			Variable:variable
		]
		(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
			// Variable is an empty query so we do a count.
			{variable[1][1].push(['Count', '*'])}
			-> ['Between', variable, ['Number', minCard], ['Number', maxCard]]
		|	// Otherwise we're an attribute
			{['Exists', variable]}:exists
			(	?(minCard == 0)
				(	?(maxCard == 0)
					// Between 0 and 0 is not exists.
					-> ['Not', exists]
					// Between 0 and 1+ is always the case for an attribute as the max is 1
				|	-> ['Boolean', true]
				)
			|	?(minCard == 1)
				// Between 1 and .. is existent.
				-> exists
			|	// And anything else is impossible.
				-> ['Boolean', false]
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Disjunction =
		[	'Disjunction'
			RulePart:first
			RulePart+:rest
		]
		-> ['Or', first].concat(rest),
	Conjunction =
		[	'Conjunction'
			RulePart:first
			RulePart+:rest
		]
		-> ['And', first].concat(rest),
	Exists =
		[	'ExistentialQuantification'
			Variable:variable
		]
		{['Exists', variable]}:where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Negation =
		[	'LogicalNegation'
			(	Negation:n
				// A hack to avoid double negation due to UniversalQuantification
				-> n[1]
			|	RulePart:whereBody
				-> ['Not', whereBody]
			):x
		]
		-> x,


	RulePart =
		(	AtomicFormulation
		|	AtLeast
		|	Exactly
		|	Exists
		|	Negation
		|	Range
		|	Disjunction
		|	Conjunction
		|	UniversalQuantification
		|	:x
			{console.error('Hit unhandled operation:', x)}
			?(false)
		),

	RuleBody =
		[
			(	'ObligationFormulation'
			|	'NecessityFormulation'
			|	'PossibilityFormulation'
			|	'PermissibilityFormulation'
			)
			RulePart:rule
		]
		-> rule,

	ReconstructIdentifier :bindIdentifier =
		-> [bindIdentifier.type, bindIdentifier.name, bindIdentifier.vocab],

	ProcessAtomicFormulations =
		{this.bindAttributes = []}
		{this.nonPrimitiveExists = false}
		ProcessAtomicFormulationsRecurse('ProcessAtomicFormulationsAttributes')
		ProcessAtomicFormulationsRecurse('ProcessAtomicFormulationsNonPrimitive')
		ProcessAtomicFormulationsRecurse('ProcessAtomicFormulationsNativeProperties'),
	ProcessAtomicFormulationsRecurse :rule =
		&(
			ProcessAtomicFormulationsLevel(rule):inputs
			{	for(var i = 0; i < inputs.length; i++) {
					// `_prependInput` lets us pass a string/array and ometa will convert it to an input, this relies on us
					// being at the end of the current input so that in practice prepending means setting the input.
					this._prependInput(inputs[i]);
					// Add the next level inputs to the current inputs, so that we process all levels 1s, then all level 2s, etc. in order to be fully breadth first.
					inputs = inputs.concat(this._applyWithArgs('ProcessAtomicFormulationsLevel', rule));
				}
			}
		)
	,
	ProcessAtomicFormulationsLevel :rule =
		{[]}:nextLevelInputs
		// First step is a breadth first search through the input to find all the atomic formulations and create bindings for them.
		(
			(	// Bit of a hack, but we only want to drill into the input if it's an array, otherwise we get infinite recursion.
				?(Array.isArray(this.input.hd))
				[	'AtomicFormulation'
					[	'FactType'
						anything+:factType
					]
					UnmappedFactType(factType):unmappedFactType
					MappedFactType(factType):actualFactType
					{this._applyWithArgs(rule, unmappedFactType, actualFactType)}
				|	(	anything:nextLevelInput
						// Accumulate the next level inputs to return them
						{nextLevelInputs.push(nextLevelInput)}
					)+
				]
			|	anything
			)*
		)
		-> nextLevelInputs
	,
	ProcessAtomicFormulationsNonPrimitive :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		{	for(var i=0; i < binds.length; i++) {
				if(!this.IsPrimitive(this.ReconstructIdentifier(binds[i].identifier))) {
					this.nonPrimitiveExists = true;
					break;
				}
			}
		},
	ProcessAtomicFormulationsAttributes :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		(	?(this.attributes.hasOwnProperty(unmappedFactType) && this.attributes[unmappedFactType])
			// Find the "base" binding - the one that isn't primitive
			{binds.find(function(bind) {
				return !$elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
			})}:baseBinding
			// Use the "base" binding in the attribute binding list, but only if we are as shallow as possible.
			{binds.find(function(bind) {
				return $elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier))
					&& $elf.bindAttributes[bind.number] == null;
			})}:attrBinding
			?attrBinding
			{_.cloneDeep(unmappedFactType)}:baseAttrFactType
			{baseAttrFactType[2][1] = attrBinding.identifier.name}
			FactTypeFieldName(baseAttrFactType):attrFieldName
			{this.bindAttributes[attrBinding.number] = {binding: ['ReferencedField', baseBinding.binding[1], attrFieldName]}}
		|	// Ignore primitive only fact types.
			?binds.some(function(bind) {
				return !$elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
			})
			LinkTableAlias(binds, actualFactType):tableAlias
			{	for(var i = 0; i < actualFactType.length; i += 2) {
					var table = this.GetTable(actualFactType[i][1]),
						bindNumber = binds[i/2].number;
					if(table && table.primitive && this.bindAttributes[bindNumber] == null) {
						this.bindAttributes[bindNumber] = {
							binding: ['ReferencedField', tableAlias, actualFactType[i][1]]
						};
					}
				}
			}
		),
	ProcessAtomicFormulationsNativeProperties :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		?binds.every(function(bind) {
			return $elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
		})
		?(binds.length == 2)
		{actualFactType[0][1]}:primitive
		{actualFactType[1][1]}:verb
		{actualFactType[2][1]}:property
		?(this.sbvrTypes[primitive] &&
			this.sbvrTypes[primitive].nativeProperties &&
			this.sbvrTypes[primitive].nativeProperties[verb] &&
			this.sbvrTypes[primitive].nativeProperties[verb][property])
		(	?(this.bindAttributes[binds[1].number] == null)
			{this.sbvrTypes[primitive].nativeProperties[verb][property](binds[0].binding, binds[1].binding)}:binding
			{this.bindAttributes[binds[1].number] = {binding: binding}}
		)?,

	Rule =
		ResetRuleState
		[	'Rule'
			&ProcessAtomicFormulations
			(	?this.nonPrimitiveExists
				RuleBody
			|	anything
			):ruleBody
			[	'StructuredEnglish'
				:ruleText
			]
			(	?this.nonPrimitiveExists
				{
					this.lfInfo.rules[ruleText] = {
						root: this.ruleRoot
					}
				}
				{this.rules.push(['Rule', ['Body', ruleBody], ['StructuredEnglish', ruleText]])}
			// |	{console.warn('Ignoring rule with only primitives: ', ruleText, ruleBody)}
			)?
		],

	Process =
		[	'Model'
			(	[	'Vocabulary'
					:vocab
					:attributes
				|	(	'Term'
					|	'Name'
					):type
					 IdentifierName:identifierName
					 :vocab
					 AddVocabulary(vocab)
					 Attributes([type, identifierName, vocab])
				|	'FactType'
					FactType:factType
					Attributes(factType)
				]
			|	Rule
			)+
		]
		{{}}:hasDependants
		{
			_.forEach(this.tables, function(table) {
				_.forEach(table.fields, function(field) {
					if (field.dataType === 'ForeignKey' || field.dataType === 'ConceptType') {
						hasDependants[field.references.resourceName] = true;
					}
				})
			})
		}
		-> { // We omit any tables that are primitives and not depended upon.
			tables: _.omitBy(this.tables, function(table, resourceName) {
				return typeof table === 'string' || (table.primitive && !hasDependants[resourceName]);
			}),
			functions: {
				trigger_update_modified_at: updateModifiedAt
			},
			relationships: this.relationships,
			rules: this.rules,
			synonyms: this.synonyms,
			lfInfo: this.lfInfo
		}
	,

	GetReference :table :field =
		-> { resourceName: table.resourceName, fieldName: field || table.idField }
}

LF2AbstractSQL.CreateTable = function(resourceName, modelName) {
	var table = {
		fields: [],
		primitive: false,
		name: null,
		indexes: [],
		idField: null,
		resourceName: resourceName,
		modelName: modelName,
		triggers: []
	};
	this.AddTableField(table, 'created at', 'Date Time', true, null, null, 'CURRENT_TIMESTAMP')
	this.AddTableField(table, 'modified at', 'Date Time', true, null, null, 'CURRENT_TIMESTAMP')
	this.AddTableTrigger(table, 'BEFORE', 'UPDATE', 'ROW', 'trigger_update_modified_at')
	return this.tables[resourceName] = table
}

LF2AbstractSQL.AddTableTrigger = function(table, when, operation, level, fnName) {
	table.triggers.push({
		when: when,
		operation: operation,
		level: level,
		fnName: fnName
	});
}

LF2AbstractSQL.AddTableField = function(table, fieldName, dataType, required, index, references, defaultValue) {
	var fieldID = this.GetTableFieldID(table, fieldName);
	if(fieldID === false) {
		var f = {
			dataType: dataType,
			fieldName: fieldName,
			required: required
		}
		if(references != null) {
			f.references = references;
		}
		if(index != null) {
			f.index = index;
		}
		if(defaultValue != null) {
			f.defaultValue = defaultValue;
		}
		table.fields.push(f);
	}
	return fieldID;
};

LF2AbstractSQL.AddRelationship = function(resourceName, factType, fieldName, references, forceHas) {
	var $elf = this;

	if (forceHas !== true && factType[0][1] === 'has') {
		// If this is an `x has y` fact type then also add an entry for the relationship without the 'has'
		var strippedFactType = _.clone(factType);
		strippedFactType.shift();
		this.AddRelationship(resourceName, strippedFactType, fieldName, references);
	}

	if (_.isObject(resourceName)) {
		// We actually had a "table" object passed in, so take its resourceName
		resourceName = resourceName.resourceName;
	}
	if (this.relationships[resourceName] == null) {
		this.relationships[resourceName] = {};
	}

	var relationships = this.relationships[resourceName];
	_(factType).flatMap(function(factTypePart) {
		return $elf.ResolveSynonym(factTypePart[1]).split('-');
	}).each(function(partName) {
		if (relationships[partName] == null) {
			relationships[partName] = {};
		}
		relationships = relationships[partName];
	})

	var relationReference = [ fieldName ];
	if (references != null) {
		relationReference.push([ references.resourceName, references.fieldName ]);
	}

	relationships.$ = relationReference;
};

LF2AbstractSQL.FactTypeFieldName = function(factType) {
	if (factType.length > 3) {
		// We don't currently handle multiple term fact types
		throw new Error('Multiple term fact types are unsupported')
	}
	if (factType.length === 2) {
		// Boolean fact type is just the verb
		return factType[1][1];
	}
	if (factType[1][1] === 'has') {
		// Otherwise if it's a has we just use the term
		return factType[2][1];
	}
	// Otherwise we use verb-term
	return factType[1][1] + '-' + factType[2][1];
};

LF2AbstractSQL.JoinOptimization = function(query, whereBody) {
	if (whereBody[0] == 'And') {
		// If the where clause is an `AND` then check through each branch to see if it can be optimized
		for (var i = 1; i < whereBody.length; i++) {
			if (this.JoinOptimization(query, whereBody[i])) {
				// If we optimized it away then remove it
				whereBody.splice(i, 1);
				// And decrement i to recognize that we removed it
				i--;
			}
		}
		if (whereBody.length === 1) {
			return true;
		}
	} else if (
		whereBody[0] == 'Exists' &&
		(whereBody[1][0] == 'SelectQuery' ||
			whereBody[1][0] == 'InsertQuery' ||
			whereBody[1][0] == 'UpdateQuery' ||
			whereBody[1][0] == 'UpsertQuery')
	) {
		// If the where clause is an `EXISTS($query)` then it can be optimized into a join for LF
		whereBody = whereBody[1].slice(1);
		for (var i = 0; i < whereBody.length; i++) {
			if (whereBody[i][0] == 'From') {
				query.push(whereBody[i]);
			}
		}
		for (var i = 0; i < whereBody.length; i++) {
			if (whereBody[i][0] == 'Where') {
				this.AddWhereClause(query, whereBody[i][1]);
			}
		}
		return true;
	}
	return false;
}

LF2AbstractSQL.AddWhereClause = function(query, whereBody) {
	// TODO: Move these to optimisation passes?
	// Check if it's true == true
	if (_.isEqual(whereBody, ['Equals', ['Boolean', true], ['Boolean', true]])) {
		return;
	}
	// Check if it's a place where we can do a join optimisation.
	if (this.JoinOptimization(query, whereBody)) {
		// We optimized away the entire thing so we don't need to add it at all
	}
	else {
		// Some is left so we add it
		for(var i=1; i < query.length; i++) {
			if(query[i][0] == 'Where') {
				query[i][1] = ['And', query[i][1], whereBody];
				return;
			}
		}
		query.push(['Where', whereBody]);
	}
};

LF2AbstractSQL.CreateConceptTypesResolver = function(query, identifier, varNum) {
	var parentAlias = identifier.name + varNum,
		concept = this.ReconstructIdentifier(identifier),
		conceptTypeResolutions,
		$elf = this;

	// Assume the first variable we encounter is the root table. Save it and
	// its alias to be returned as extra metadata for this rule
	if (this.ruleRoot === null) {
		this.ruleRoot = {
			table: this.GetTable(identifier.name).name,
			alias: parentAlias
		};
	}

	if(this.conceptTypeResolvers[parentAlias]) {
		throw new Error('Concept type resolver already added for "' + parentAlias + '"!')
	}

	conceptTypeResolutions = [];

	var conceptTypeResolver = (function(untilConcept) {
		var conceptTable,
			conceptAlias;

		if (conceptTypeResolutions.length === 0) {
			// Resolve the initial level on first call
			conceptTypeResolutions.push(identifier.name);
			query.push(['From', ['Alias', ['Table', this.GetTable(identifier.name).name], parentAlias]])
			this.ResolveLinkTable(parentAlias);
		}

		// Pick up where we left off with previous concept type resolutions
		parentAlias = _.last(conceptTypeResolutions);
		if(parentAlias === true || conceptTypeResolutions.includes(untilConcept)) {
			// We already either resolved the entire chain, or at least as far as we need to, so we can just return :)
			return;
		}
		while((concept = this.FollowConceptType(concept)) !== false) {
			conceptAlias = concept[1] + varNum;
			conceptTable = this.GetTable(concept[1]);
			if(conceptTable.primitive !== false) {
				break;
			}
			query.push(['From', ['Alias', ['Table', conceptTable.name], conceptAlias]]);
			this.AddWhereClause(query, ['Equals', ['ReferencedField', parentAlias, concept[1]], ['ReferencedField', conceptAlias, conceptTable.idField]]);
			this.ResolveLinkTable(parentAlias);

			parentAlias = conceptAlias;
			conceptTypeResolutions.push(parentAlias);
			if (untilConcept != null && !this.IdentifiersEqual(concept, untilConcept)) {
				// We've added the concept that was needed, we can exit now
				break;
			}
		}
		if(concept === false) {
			// We finished resolving the entire chain, so we can avoid attempting it in future
			conceptTypeResolutions.push(true);
		}
	}).bind(this);

	this.conceptTypeResolvers[parentAlias] = conceptTypeResolver;

	return function() {
		// Return a helper function that when called checks that there is input in a buffer and that it's
		// not an AtomicFormulation, if so then we resolve the base term, the reason AtomicFormulation is
		// special is because it just says that we've reached the end and how to link to the created var,
		// and doesn't actually use it at all
		var next = $elf.input.head();
		if (next && next[0] !== 'AtomicFormulation') {
			conceptTypeResolver(identifier.name);
		}
	}
};

LF2AbstractSQL.ResolveLinkTable = function(tableAlias) {
	if (this.linkTableResolvers[tableAlias] === LINK_RESOLVE_DONE) {
		return;
	}
	if (typeof this.linkTableResolvers[tableAlias] === 'function') {
		this.linkTableResolvers[tableAlias]();
	} else {
		this.linkTableResolvers[tableAlias] = LINK_RESOLVE_QUEUED;
	}
}
LF2AbstractSQL.CreateLinkTableResolver = function(query, linkTableAlias, bind, relationshipMapping) {
	var parentAlias = bind.identifier.name + '.' + bind.number,
		$elf = this;

	var linkTableResolver = function() {
		$elf.linkTableResolvers[parentAlias] = LINK_RESOLVE_DONE;
		bind.used();
		$elf.AddWhereClause(query,
			['Equals',
				['ReferencedField', linkTableAlias, relationshipMapping[0]],
				['ReferencedField', bind.binding[1], relationshipMapping[1][1]]
			]
		);
	};
	// If it's queued run it immediately, if it's already been done then that means this is a different link table from the same resource and
	// we should also immediately resolve for this one, and if the bind is for a numbered identifier then assume it will be used at some point
	if (this.linkTableResolvers[parentAlias] === LINK_RESOLVE_QUEUED || this.linkTableResolvers[parentAlias] === LINK_RESOLVE_DONE || bind.identifier.num != null) {
		linkTableResolver();
	} else if (typeof this.linkTableResolvers[parentAlias] === 'function') {
		var existingLinkTableResolver = this.linkTableResolvers[parentAlias];
		this.linkTableResolvers[parentAlias] = function() {
			existingLinkTableResolver();
			linkTableResolver();
		}
	} else {
		this.linkTableResolvers[parentAlias] = linkTableResolver;
	}
};

LF2AbstractSQL.initialize = function() {
	this.reset();
	this.sbvrTypes = {};
	this.termForms = {};
};

LF2AbstractSQL.reset = function() {
	SBVRCompilerLibs.initialize.call(this);
	this.tables = {};
	this.relationships = {};
	this.synonymousForms = {};
	this.rules = [];
	this.attributes = {};
	this.bindAttributes = [];
	this.lfInfo = {
		rules: {}
	};
	this.ResetRuleState();
};

LF2AbstractSQL.ResetRuleState = function() {
	this.conceptTypeResolvers = {};
	this.linkTableResolvers = {};
	this.ruleRoot = null;
};

LF2AbstractSQL.addTypes = function(types) {
	Object.assign(this.sbvrTypes, types);
};
