var SBVRCompilerLibs = require('./sbvr-compiler-libs').SBVRCompilerLibs,
	_ = require('lodash');
export ometa LF2AbstractSQL <: SBVRCompilerLibs {
	Number =
		[	'Number'
			number:num
			?{!isNaN(num)}
		]
		-> num,

	Real =
		[	'Real'
			number:num
			?{!isNaN(num)}
		]
		-> ['Real', num],

	Integer =
		[	'Integer'
			number:num
			?{!isNaN(num)}
		]
		-> ['Integer', num],

	Text =
		[	'Text'
			anything:text
		]
		-> ['Text', text],
		
	Value =
			Real
		|	Integer
		|	Text,
	
	/** Terms **/
	Identifier =
		{''}:num
		[	(	'Term'
			|	'Name'
			):type
			:name
			:vocab
			(	// Var number
				Number:num
			|	// Or embedded data, which we ignore the embedded data as it is retreived from the binding instead
				Value
			)?
		]
		-> {type: type, name: name, num: num, vocab: vocab},
	
	IdentifierName =
		:identifierName
		GetResourceName(identifierName):resourceName
		(	?(!this.tables.hasOwnProperty(resourceName))
		|	{console.error('We already have an identifier with a name of: ' + identifierName)} ?(false)
		)
		{this.identifiers[identifierName] = identifierName}
		{this.tables[resourceName] = this.CreateTable()}
		-> identifierName,
	Attributes :termOrFactType =
			end
		|	[	'Attributes'
				(	[	:attributeName ApplyFirstExisting(['Attr' + attributeName, 'DefaultAttr'], [termOrFactType]):attributeValue
					]
				)*
			],
	DefaultAttr :termOrFactType =
		:anything,
		// {console.log('Default', termOrFactType, anything)},
	AttrConceptType :termOrFactType =
		[	'Term'
			:conceptType
			:vocab
		]:term
		{	if (this.termForms[termOrFactType]) {
				termOrFactType = this.termForms[termOrFactType];
			}
		}
		{this.vocabularies[termOrFactType[2]]['ConceptTypes'][termOrFactType] = term}

		IsPrimitive(term):primitive
		GetTable(conceptType):conceptTable
		GetTable(termOrFactType[1]):identifierTable
		(	?(primitive !== false && conceptType === primitive)
			{primitive}:dataType
			// If the concept type is primitive then we use that as the "value" field and delete the current.
			(	?(identifierTable.hasOwnProperty('referenceScheme'))
				GetTableFieldID(identifierTable, identifierTable.referenceScheme):fieldID
				?(fieldID !== false)
				{identifierTable.fields.splice(fieldID, 1)}
			)?
			{identifierTable.referenceScheme = conceptType}
		|	{'ConceptType'}:dataType
			{{tableName: conceptTable.name, fieldName: conceptTable.idField}}:references
		)
		AddTableField(identifierTable, conceptType, dataType, true, null, references),
	AttrDatabaseIDField :termOrFactType =
		:idField
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?_.isString(table)
		|	(	AddTableField(table, idField, 'Serial', true, 'PRIMARY KEY'):fieldID
				(	?(fieldID !== false)
					// If the field already exists then update it instead.
					{table.fields[fieldID].index = 'PRIMARY KEY'}
				)?
			)
			{table.idField = idField}
		),
	AttrReferenceScheme :termOrFactType =
		:referenceScheme
		(	?_.isArray(referenceScheme)
			-> referenceScheme[1]
		|	-> referenceScheme
		):referenceScheme
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?_.isString(table)
		|	// Find existing name field and update it if it exists.
			(	?(table.hasOwnProperty('referenceScheme'))
				GetTableFieldID(table, table.referenceScheme):fieldID
				?(fieldID !== false)
				{table.fields[fieldID].fieldName = referenceScheme}
			)?
			{table.referenceScheme = referenceScheme}
		),
	AttrDatabaseTableName :termOrFactType =
		:tableName
		GetTableID(termOrFactType):tableID
		GetTable(tableID):table
		(	?_.isString(table)
		|	{table.name = tableName}
		),
	AttrDatabasePrimitive :termOrFactType =
		:attrVal
		GetTableID(termOrFactType):tableID
		{this.GetTable(tableID).primitive = attrVal},
	AttrDatabaseAttribute :factType =
		:attrVal
		(	?attrVal
			{this.attributes[factType] = attrVal}
			{this.tables[this.GetResourceName(factType)] = 'Attribute'}
			GetTable(factType[0][1]):baseTable
			{factType[2][1]}:attributeName
			GetTable(attributeName):attributeTable
			GetTableFieldID(baseTable, attributeName):fieldID
			{baseTable.fields[fieldID].dataType = attributeTable.primitive}
		)?,
	AttrForeignKey :factType =
		:required
		GetTable(factType[0][1]):baseTable
		{factType[2][1]}:fkName
		GetTable(fkName):fkTable
		(	?(baseTable.idField == fkName)
			// If the foreign key matches the id field then delete the current field before adding the new.
			GetTableFieldID(baseTable, fkName):fieldID
			?(fieldID !== false)
			{baseTable.fields.splice(fieldID, 1)}
		)?
		AddTableField(baseTable, fkName, 'ForeignKey', required, null, {tableName: fkTable.name, fieldName: fkTable.idField}):fieldID
		(	?fieldID
			// Field already exists, so we manually set the required attr
			{baseTable.fields[fieldID].required = required}
		)?
		{this.tables[this.GetResourceName(factType)] = 'ForeignKey'},
	AttrUnique :factType =
		// TODO: This needs to have the dependency of coming after ForeignKey/Attribute attrs removed.
		:required
		GetTable(factType):baseTable
		(	?(baseTable === 'Attribute' || baseTable === 'ForeignKey')
			GetTable(factType[0][1]):baseTable
		)?
		{factType[2][1]}:uniqueField
		GetTableFieldID(baseTable, uniqueField):fieldID
		?(fieldID !== false)
		{baseTable.fields[fieldID].index = 'UNIQUE'},
	// AttrSynonym :term =
		// :synonym {this.identifiers[synonym[1]] = term[1]},
	AttrSynonymousForm :factType =
		:synForm
		AddFactType(synForm, factType),
	AttrTermForm :factType =
		:term
		{	this.termForms[factType] = term;
			this.identifiers[term[1]] = factType;
			this.tables[this.GetResourceName(term[1])] = this.GetTable(factType);
			for(var i = 0; i < factType.length; i++) {
				if(factType[i][0] === 'Term') {
					var extraFactType = [term, ['Verb', 'has', false], factType[i]];
					this.AddFactType(extraFactType, extraFactType);
					this.tables[this.GetResourceName(extraFactType)] = this.GetTable(factType[i][1]).primitive ? 'Attribute' : 'ForeignKey';
				}
			}
		},
	AttrNecessity :tableID =
		Rule,
	
	/** Fact Types **/
	FactType =
		&((:factTypePart &(:attributes) -> factTypePart)+:factType)
		AddFactType(factType, factType)
		(	?(this.IsPrimitive(factType[0]))
			// Eat input
			(:factTypePart &(:attributes))+
		|	GetResourceName(factType):resourceName
			(	?(factType.length == 2)
				// Eat input
				(:factTypePart &(:attributes))+
				GetTable(factType[0][1]):identifierTable
				AddTableField(identifierTable, factType[1][1], 'Boolean', true)
				{this.tables[resourceName] = 'BooleanAttribute'}
			|	{this.tables[resourceName] = this.CreateTable()}:linkTable
				{[]}:uniqueFields
				(	Identifier:identifier
					{identifier.name + identifier.num}:fieldName
					{uniqueFields.push(fieldName)}
					GetTable(identifier.name):fkTable
					(	?fkTable.primitive
						AddTableField(linkTable, fieldName, fkTable.primitive, true)
					|	AddTableField(linkTable, fieldName, 'ForeignKey', true, null, {tableName: fkTable.name, fieldName: fkTable.idField})
					)
				|	['Verb' :verb :negated]
				)+
				{linkTable.indexes.push({type: 'UNIQUE', fields: uniqueFields})}
			)
		)
		-> factType,
	
	Cardinality =
		[
			(	'MinimumCardinality'
			|	'MaximumCardinality'
			|	'Cardinality'
			)
			Number:cardinality
		]
		-> cardinality,

	Variable =
		[	'Variable'
			Number:num
			Identifier:identifier
			(	// Don't add this var if it's an attribute binding.
				{this.bindAttributes[num]}:bind
				?bind
				{_.clone(bind.binding)}:selectBody
				-> ['SelectQuery', ['Select', [selectBody]]]
			|	{'.' + num}:varNum
				{['SelectQuery', ['Select', []], ['From', [this.GetTable(identifier.name).name, identifier.name + varNum]]]}:query
				ResolveConceptTypes(query, identifier, varNum)
				-> query
			):query
			(	RulePart:whereBody
				(	?query
					AddWhereClause(query, whereBody)
				)?
			)?
		]
		(	RulePart:whereBody2
			AddWhereClause(query, whereBody2)
		)?
		(	?(!_.some(query, {0: 'From'}))
			(	{_.find(query, {0: 'Where'})}:whereBody
				?whereBody
				{selectBody.whereBody = whereBody[1]}
			)?
			-> selectBody
		|	-> query
		),

	// Return role bindings as they would be found in the actual fact type.
	RoleBindings :actualFactType =
		{[]}:binds
		{	for(var i = 0; i < actualFactType.length; i += 2) {
				var j = _.findIndex(actualFactType, {3: i});
				// Map the bind into the position matching that of the fact type.
				binds[j/2] = this.RoleBinding(actualFactType[j][1]);
			}
		}
		end
		-> binds
	,

	RoleBinding :baseTermName =
		[	'RoleBinding'
			Identifier:identifier
			(	number:number
			|	Value:data
			)
		]
		{this.bindAttributes[number]}:baseBind
		(	?data
			-> data
		|	?baseBind
			-> baseBind.binding
		|	-> ['ReferencedField', baseTermName + '.' + number, identifier.name]
		):binding
		-> {
			identifier: identifier,
			number: number,
			data: data,
			binding: binding
		},

	NativeProperty :actualFactType =
		?(this.IsPrimitive(actualFactType[0]))
		?(this.IsPrimitive(actualFactType[2]))
		RoleBindings(actualFactType):binds
		?(binds.length == 2)
		{actualFactType[0][1]}:primitive
		{actualFactType[1][1]}:verb
		{actualFactType[2][1]}:property
		?(this.sbvrTypes[primitive] &&
			this.sbvrTypes[primitive].nativeProperties &&
			this.sbvrTypes[primitive].nativeProperties[verb] &&
			this.sbvrTypes[primitive].nativeProperties[verb][property])
		-> ['Equals', ['Boolean', true], ['Boolean', true]],

	NativeFactType :actualFactType =
		?(actualFactType.length == 3)
		?(this.IsPrimitive(actualFactType[0]))
		?(this.IsPrimitive(actualFactType[2]))
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{actualFactType[0][1]}:primitive
			{actualFactType[1][1]}:verb
			{actualFactType[2][1]}:secondPrimitive
			?(this.sbvrTypes[primitive] &&
				this.sbvrTypes[primitive].nativeFactTypes &&
				this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive] &&
				this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb])
			-> this.sbvrTypes[primitive].nativeFactTypes[secondPrimitive][verb](binds[0].binding, binds[1].binding)
		|	___NativeFactTypeMatchingFailed___.die
		),


	LinkTableAlias =
		[	(	:binding
				-> binding.number
			)+:bindNumbers
		]
		[	(	[	(	'Verb'
						:verb
						anything
						-> verb
					|	:identifierType
						:identifierName
						:vocab
						anything?:mapping
						-> (identifierName + '.' + bindNumbers.shift())
					):partAlias
				]
				-> partAlias
			)*:factType
		]
		-> factType.join('-'),
	LinkTable :actualFactType =
		RoleBindings(actualFactType):binds
		LinkTableAlias(binds, actualFactType):tableAlias
		{['SelectQuery', ['Select', []], ['From', [this.GetTable(actualFactType).name, tableAlias]]]}:query
		{	_.each(binds, function(bind, i) {
				var baseIdentifierName = actualFactType[i*2][1],
					table = $elf.GetTable(baseIdentifierName);
				if(!table.primitive) {
					$elf.AddWhereClause(query, ['Equals', ['ReferencedField', tableAlias, baseIdentifierName], ['ReferencedField', bind.binding[1], table.idField]]);
				}
			})
		}
		-> ['Exists', query],
	
	ForeignKey :actualFactType =
		?(this.GetTable(actualFactType) == 'ForeignKey')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{binds[0]}:bindFrom
			{binds[1]}:bindTo
			{actualFactType[2]}:baseToIdentifier
			GetTable(baseToIdentifier[1]):tableTo
		|	___ForeignKeyMatchingFailed___.die
		)
		-> ['Equals', ['ReferencedField', bindFrom.binding[1], baseToIdentifier[1]], ['ReferencedField', bindTo.binding[1], tableTo.idField]],

	BooleanAttribute :actualFactType =
		?(this.GetTable(actualFactType) == 'BooleanAttribute')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 1)
			{actualFactType[1][1]}:attributeName
			{actualFactType[1][2]}:negated
		|	{console.error(this.input)}
			___BooleanAttributeMatchingFailed___.die
		)
		-> ['Equals', ['ReferencedField', binds[0].binding[1], attributeName], ['Boolean', !negated]],

	Attribute :actualFactType =
		?(this.GetTable(actualFactType) == 'Attribute')
		(	RoleBindings(actualFactType):binds
			?(binds.length == 2)
			{binds[0]}:bindReal
			{binds[1]}:bindAttr
			|	___AttributeMatchingFailed___.die
		)
		(	{this.bindAttributes[bindAttr.number]}:bind
			{bindAttr.binding = ['ReferencedField', bindReal.binding[1], bind.binding[2]]}
			?(!_.isEqual(bindAttr.binding, bind.binding))
			// If we're not the first bind we make sure we match it.
			-> ['Equals', bindAttr.binding, bind.binding]
		|	// Otherwise return true = true, just so things work.
			-> ['Equals', ['Boolean', true], ['Boolean', true]]
		),
	
	AtomicFormulation =
		[	'AtomicFormulation'
			[	'FactType'
				anything+:factType
			]
			MappedFactType(factType):actualFactType
			(	NativeProperty(actualFactType)
			|	NativeFactType(actualFactType)
			|	ForeignKey(actualFactType)
			|	BooleanAttribute(actualFactType)
			|	Attribute(actualFactType)
			|	LinkTable(actualFactType)
			):whereClause
		]
		-> whereClause,
	AtLeast =
		[	'AtLeastNQuantification'
			Cardinality:minCard
			Variable:variable
		]
		(	?(minCard == 0)
			// At least 0? Well that's always true..
			-> ['Boolean', true]
		|	(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
				// Variable is an empty query so we do a count.
				{variable[1][1].push(['Count', '*'])}
				-> ['GreaterThanOrEqual', variable, ['Number', minCard]]
			|	// Otherwise we're an attribute
				(	?(minCard > 1)
					// And to have more than one of an attribute is impossible.
					-> ['Boolean', false]
				|	-> ['Exists', variable]
				)
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Exactly =
		[	'ExactQuantification'
			Cardinality:card
			Variable:variable
		]
		(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
			// Variable is an empty query so we do a count.
			{variable[1][1].push(['Count', '*'])}
			-> ['Equals', variable, ['Number', card]]
		|	// Otherwise we're an attribute
			{['Exists', variable]}:exists
			(	?(card == 0)
				// Exactly 0 attributes is a non-existent (null) attribute
				-> ['Not', exists]
			|	?(card == 1)
				// Exactly 1 is existent.
				-> exists
			|	// And anything else is impossible.
				-> ['Boolean', false]
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Range =
		[	'NumericalRangeQuantification'
			Cardinality:minCard
			Cardinality:maxCard
			Variable:variable
		]
		(	?(variable[0] == 'SelectQuery' && variable[1][1].length == 0)
			// Variable is an empty query so we do a count.
			{variable[1][1].push(['Count', '*'])}
			-> ['Between', variable, ['Number', minCard], ['Number', maxCard]]
		|	// Otherwise we're an attribute
			{['Exists', variable]}:exists
			(	?(minCard == 0)
				(	?(maxCard == 0)
					// Between 0 and 0 is not exists.
					-> ['Not', exists]
					// Between 0 and 1+ is always the case for an attribute as the max is 1
				|	-> ['Boolean', true]
				)
			|	?(minCard == 1)
				// Between 1 and .. is existent.
				-> exists
			|	// And anything else is impossible.
				-> ['Boolean', false]
			)
		):where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Disjunction =
		[	'Disjunction'
			RulePart:first
			RulePart+:rest
		]
		-> ['Or', first].concat(rest),
	Conjunction =
		[	'Conjunction'
			RulePart:first
			RulePart+:rest
		]
		-> ['And', first].concat(rest),
	Exists =
		[	'ExistentialQuantification'
			Variable:variable
		]
		{['Exists', variable]}:where
		(	?variable.whereBody
			-> ['And', variable.whereBody, where]
		|	-> where
		),
	Negation =
		[	'LogicalNegation'
			RulePart:whereBody
		]
		-> ['Not', whereBody],
		
	
	RulePart =
		(	AtomicFormulation
		|	AtLeast
		|	Exactly
		|	Exists
		|	Negation
		|	Range
		|	Disjunction
		|	Conjunction
		|	:x
			{console.error('Hit unhandled operation:', x)}
			?(false)
		),
	
	RuleBody =
		[
			(	'ObligationFormulation'
			|	'NecessityFormulation'
			|	'PossibilityFormulation'
			|	'PermissibilityFormulation'
			)
			RulePart:rule
		]
		-> rule,

	ReconstructIdentifier :bindIdentifier =
		-> [bindIdentifier.type, bindIdentifier.name, bindIdentifier.vocab],

	ProcessAtomicFormulations =
		{this.bindAttributes = []}
		{this.bindAttributeDepth = []}
		{this.nonPrimitiveExists = false}
		&ProcessAtomicFormulationsRecurse(0, 'ProcessAtomicFormulationsAttributes')
		&ProcessAtomicFormulationsRecurse(0, 'ProcessAtomicFormulationsNonPrimitive')
		&ProcessAtomicFormulationsRecurse(0, 'ProcessAtomicFormulationsNativeProperties'),
	ProcessAtomicFormulationsRecurse :depth :rule =
		(	// Bit of a hack, but we only want to drill into the input if it's an array, otherwise we get infinite recursion.
			?(_.isArray(this.input.hd))
			[	'AtomicFormulation'
				[	'FactType'
					anything+:factType
				]
				UnmappedFactType(factType):unmappedFactType
				MappedFactType(factType):actualFactType
				{this._applyWithArgs(rule, depth, unmappedFactType, actualFactType)}
			|	ProcessAtomicFormulationsRecurse(depth+1, rule)
			]
		|	anything
		)*,
	ProcessAtomicFormulationsNonPrimitive :depth :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		{	for(var i=0; i < binds.length; i++) {
				if(!this.IsPrimitive(this.ReconstructIdentifier(binds[i].identifier))) {
					this.nonPrimitiveExists = true;
					break;
				}
			}
		},
	ProcessAtomicFormulationsAttributes :depth :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		(	?(this.attributes.hasOwnProperty(unmappedFactType) && this.attributes[unmappedFactType])
			// Find the "base" binding - the one that isn't primitive
			{_.find(binds, function(bind) {
				return !$elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
			})}:baseBinding
			// Use the "base" binding in the attribute binding list, but only if we are as shallow as possible.
			{_.find(binds, function(bind) {
				return $elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier))
						&& ($elf.bindAttributeDepth[bind.number] == null || $elf.bindAttributeDepth[bind.number] > depth);
			})}:attrBinding
			{	this.bindAttributeDepth[attrBinding.number] = depth;
				this.bindAttributes[attrBinding.number] = {binding: ['ReferencedField', baseBinding.binding[1], attrBinding.identifier.name]};
			}
		|	// Ignore primitive only fact types.
			?_.some(binds, function(bind) {
				return !$elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
			})
			LinkTableAlias(binds, actualFactType):tableAlias
			{	for(var i = 0; i < actualFactType.length; i += 2) {
					var table = this.GetTable(actualFactType[i][1]),
						bindNumber = binds[i/2].number;
					if(table && table.primitive && (
						this.bindAttributeDepth[bindNumber] == null ||
						this.bindAttributeDepth[bindNumber] > depth
					)) {
						this.bindAttributeDepth[bindNumber] = depth;
						this.bindAttributes[bindNumber] = {
							binding: ['ReferencedField', tableAlias, actualFactType[i][1]]
						};
					}
				}
			}
		),
	ProcessAtomicFormulationsNativeProperties :depth :unmappedFactType :actualFactType =
		RoleBindings(actualFactType):binds
		?_.every(binds, function(bind) {
			return $elf.IsPrimitive($elf.ReconstructIdentifier(bind.identifier));
		})
		?(binds.length == 2)
		{actualFactType[0][1]}:primitive
		{actualFactType[1][1]}:verb
		{actualFactType[2][1]}:property
		?(this.sbvrTypes[primitive] &&
			this.sbvrTypes[primitive].nativeProperties &&
			this.sbvrTypes[primitive].nativeProperties[verb] &&
			this.sbvrTypes[primitive].nativeProperties[verb][property])
		{this.sbvrTypes[primitive].nativeProperties[verb][property](binds[0].binding, binds[1].binding)}:binding
		{	this.bindAttributeDepth[binds[1].number] = depth;
			this.bindAttributes[binds[1].number] = {binding: binding};
		},
	
	Rule =
		[	'Rule'
			&ProcessAtomicFormulations
			(	?this.nonPrimitiveExists
				RuleBody
			|	anything
			):ruleBody
			[	'StructuredEnglish'
				:ruleText
			]
			(	?this.nonPrimitiveExists
				{this.rules.push(['Rule', ['Body', ruleBody], ['StructuredEnglish', ruleText]])}
			// |	{console.warn('Ignoring rule with only primitives: ', ruleText, ruleBody)}
			)?
		],
	
	Process =
		[	'Model'
			(	[	'Vocabulary'
					:vocab
					:attributes
				|	(	'Term'
					|	'Name'
					):type
					 IdentifierName:identifierName
					 :vocab
					 AddVocabulary(vocab)
					 Attributes([type, identifierName, vocab])
				|	'FactType'
					FactType:factType
					Attributes(factType)
				]
			|	Rule
			)+
		]
		{{}}:tables
		-> {tables:this.tables, rules:this.rules}
	,

	CreateTable =
		{{fields: [], primitive: false, name: null, indexes: [], idField: null}}:table
		AddTableField(table, 'created at', 'Date Time', true, null, null, 'CURRENT_TIMESTAMP')
		-> table
}

LF2AbstractSQL.AddTableField = function(table, fieldName, dataType, required, index, references, defaultValue) {
	if(references === undefined) {
		references = null;
	}
	if(index === undefined) {
		index = null;
	}
	if(defaultValue === undefined) {
		defaultValue = null;
	}
	var fieldID = this.GetTableFieldID(table, fieldName);
	if(fieldID === false) {
		table.fields.push({
			dataType: dataType,
			fieldName: fieldName,
			required: required,
			index: index,
			references: references,
			defaultValue: defaultValue
		});
	}
	return fieldID;
}

LF2AbstractSQL.AddWhereClause = function(query, whereBody) {
	// TODO: Move these to optimisation passes?
	// Check if it's true == true
	if (_.isEqual(whereBody, ['Equals', ['Boolean', true], ['Boolean', true]])) {
		return;
	}
	// Check if it's a place where we can do a join optimisation.
	if(whereBody[0] == 'Exists' && (
			whereBody[1][0] == 'SelectQuery' || whereBody[1][0] == 'InsertQuery' ||
			whereBody[1][0] == 'UpdateQuery' || whereBody[1][0] == 'UpsertQuery')) {
		whereBody = whereBody[1].slice(1);
		for(var i=0; i < whereBody.length; i++) {
			if(whereBody[i][0] == 'From') {
				query.push(whereBody[i]);
			}
		}
		for(var i=0; i < whereBody.length; i++) {
			if(whereBody[i][0] == 'Where') {
				this.AddWhereClause(query, whereBody[i][1]);
			}
		}
	}
	else {
		for(var i=1; i < query.length; i++) {
			if(query[i][0] == 'Where') {
				query[i][1] = ['And', query[i][1], whereBody];
				return;
			}
		}
		query.push(['Where', whereBody]);
	}
};

LF2AbstractSQL.ResolveConceptTypes = function(query, identifier, varNum, untilConcept) {
	var conceptAlias,
		parentAlias = identifier.name + varNum,
		concept = this.ReconstructIdentifier(identifier),
		conceptTable;
	while((untilConcept == null || !this.IdentifiersEqual(concept, untilConcept))
			&& (concept = this.FollowConceptType(concept)) !== false) {
		conceptAlias = concept[1] + varNum;
		conceptTable = this.GetTable(concept[1]);
		if(conceptTable.primitive !== false) {
			break;
		}
		query.push(['From', [conceptTable.name, conceptAlias]]);
		this.AddWhereClause(query, ['Equals', ['ReferencedField', parentAlias, concept[1]], ['ReferencedField', conceptAlias, conceptTable.idField]]);
		parentAlias = conceptAlias;
	}
};

LF2AbstractSQL.initialize = function() {
	this.reset();
	this.sbvrTypes = {};
	this.termForms = {};
};

LF2AbstractSQL.reset = function() {
	SBVRCompilerLibs.initialize.call(this);
	this.tables = {};
	this.identifiers = {}; // TODO: Is this needed?
	this.rules = [];
	this.attributes = {};
	this.bindAttributes = [];
	this.bindAttributeDepth = [];
};

LF2AbstractSQL.addTypes = function(types) {
	_.assign(this.sbvrTypes, types);
};
